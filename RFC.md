FlagGems RFC 机制设计方案
1. 目标
建立一个透明、规范的重大决策与功能演进流程，确保 FlagGems 的算子扩展和架构变更经过充分的设计审查与风险评估。在FlagOS社区治理架构中建立一个FlagGems的PMC。在社区的contribution guide中增加透明的贡献指南。

2. RFC 流程状态
• DRAFT: 提案编写中
• DISCUSSION: 社区讨论与 SIG 评审中
• FCP (Final Comment Period): 最终评论期，通常为 7 天
• ACCEPTED: 提案被接受，进入开发阶段
• REJECTED: 提案被拒绝

3. RFC 模板核心章节
• Summary: 简要描述
• Motivation: 为什么需要这个变更？
• Technical Design: 详细的设计实现（代码结构、API 等）
• Testing Plan: 验证方案（功能、精度、性能）
• Alternatives: 备选方案


---

示例 RFC：FlagGems 自动生成算子准入机制
1. 背景 (Motivation)
为了提升算子覆盖率，项目引入了基于模板或工具自动生成的 Triton 算子。由于算子数量庞大，需要一套标准化的自动化准入流程，确保不降低主分支质量。

2. 自动生成算子准入标准 (Technical Design)
所有自动生成的算子 PR 必须包含以下工件：
• 生成元数据: 记录生成工具版本及配置。
• Triton 实现: 符合 FlagGems 编码规范的算子代码。

3. 验证流水线 (Testing Plan)
1. 单元测试 (UT): 覆盖所有常用的 Input Shapes 和 Data Types，精度必须对齐参考算子。
2. 加速比测试 (Benchmarking): 在 A100/H800 等典型硬件上，相比于原生实现需有性能收益。
3. 自动化报告: PR 评论区自动挂载性能对比图表。

4. 人工复核 (Review)
• SIG-Operators 成员必须对生成的代码逻辑进行抽检。
• 确认算子的通用性，避免过度的硬件特定硬编码。

Flaggems Experimental 生成算子设计
在 FlagGems 这种高性能算子库中，设计 experimental 命名空间的核心目的在于：既能让前沿算子快速触达用户，又不破坏主框架的稳定性和 API 的严谨性。
基于 FlagGems 的结构（通常深度绑定 PyTorch 的扩展机制），我建议从代码组织、API 暴露和自动发现三个维度进行设计：

---
5. 物理结构：flaggems/experimental_ops
在文件系统层面，建立一个隔离的缓冲区。
flaggems/
├── init.py
├── ops/                  # 稳定版算子
├── experimental_ops/         # 实验性功能区
│   ├── init.py
│   ├── generated_ops/        # 存放大量自动生成的 Triton 算子
│   │   ├── init.py
│   │   ├── blas_ops.py
│   │   └── reduction_ops.py
│   └── custom_ops/       # 手写的实验性算子
└── testing/              # 自动化测试脚本

2. API 准入机制：显式导入原则
为了防止用户误用尚未完全稳定的算子，不应在 flaggems/init.py 中直接 import * 实验区内容。
- 调用方式设计：用户必须通过 flaggems.experimental_ops 路径访问。
import flaggems
# 调用稳定版
flaggems.add(a, b) 
# 显式调用实验版
flaggems.experimental_ops.generated.fast_gelu(a) 
- 自动挂载 (Monkey Patching)：如果你希望实验性算子也能无缝替换 torch 算子，可以在 experimental 初始化时提供一个开关：
# flaggems/experimental_ops/init.py
def enable_experimental_ops():
    """将实验性算子注册到全局调度或替换逻辑中"""
    from .generated import blas_ops
    # 内部逻辑：将自动生成的算子挂载到 flaggems 的 dispatch 映射表

---
3. 针对“自动生成算子”的特殊设计
由于你是通过工具大量生成的 Triton 代码，建议采用“声明式”的管理方式：
A. 元数据记录 (Metadata)
在 experimental/generated/ 下的每个文件，头部必须包含生成元数据，方便回溯。
# Generated by KernelGen v0.1
# Source: Triton
# Performance: 1.2x vs Native on A100
B. 自动化路由 (Dynamic Dispatch)
由于自动生成的算子可能针对特定的 Shape（例如 $$M, N, K$$ 的特定倍数），你可以设计一个 Experimental Dispatcher：
# flaggems/experimental/dispatcher.py
class ExperimentalDispatcher:
    def call(self, *args, **kwargs):
        # 1. 检查是否有针对当前 Shape 的优化生成算子
        # 2. 如果有，执行 experimental/generated 下的代码
        # 3. 如果没有，Fallback 到 flaggems.ops 或 torch

---
4. 毕业机制 (Graduation Policy)
实验区的算子不是永久存在的，必须在 RFC 中定义“毕业”标准：
1. 稳定期：在 experimental 目录中存在超过 1 个版本。
2. 测试通过：通过了所有 flaggems/testing 下的精度测试
3. 
4. 性能达标：在至少两款主流芯片（如昇腾、寒武纪、NVIDIA）上加速比>0.8。
5. 合并：符合条件后，由维护者将提PR，将其从 experimental/ 移动到 ops/，并在 experimental/ 中留下一个指向新位置的别名（并标记 DeprecationWarning）。PR需要通过review和CICD的所有测试。

---
提示
对于自动生成的算子，最忌讳的是代码污染。建议在 experimental/generated 下使用单独的 Code Style 检查。如果生成的代码可读性极差，需要先做一些风格的reveiw和修改。


